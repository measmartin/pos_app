/// Service for generating barcodes for products
/// 
/// This service provides functionality to generate unique barcodes
/// for products that don't have one. It uses EAN-13 format.
class BarcodeService {
  /// Country/Manufacturer code prefix for internally generated barcodes
  /// Using 200-299 range which is reserved for internal use
  static const String _prefix = '200';

  /// Generate an EAN-13 barcode based on product ID
  /// 
  /// Format: 200 + 9-digit product ID + check digit
  /// Example: 2000000000123 for product ID 123
  String generateBarcode(int productId) {
    // Pad product ID to 9 digits
    final paddedId = productId.toString().padLeft(9, '0');
    
    // Combine prefix with padded ID (12 digits total)
    final barcodeWithoutCheckDigit = '$_prefix$paddedId';
    
    // Calculate EAN-13 check digit
    final checkDigit = _calculateEan13CheckDigit(barcodeWithoutCheckDigit);
    
    // Return complete 13-digit barcode
    return '$barcodeWithoutCheckDigit$checkDigit';
  }

  /// Calculate the EAN-13 check digit
  /// 
  /// Algorithm:
  /// 1. Starting from right to left (excluding check digit position)
  /// 2. Multiply odd position digits by 3
  /// 3. Add all digits together
  /// 4. Check digit = (10 - (sum mod 10)) mod 10
  int _calculateEan13CheckDigit(String barcode) {
    if (barcode.length != 12) {
      throw ArgumentError('Barcode must be 12 digits for check digit calculation');
    }

    int sum = 0;
    
    // Process 12 digits from left to right
    for (int i = 0; i < 12; i++) {
      final digit = int.parse(barcode[i]);
      // Multiply odd positions (0, 2, 4, ...) by 1
      // Multiply even positions (1, 3, 5, ...) by 3
      sum += digit * (i.isEven ? 1 : 3);
    }

    // Calculate check digit
    final checkDigit = (10 - (sum % 10)) % 10;
    return checkDigit;
  }

  /// Validate an EAN-13 barcode
  /// 
  /// Returns true if the barcode is valid (correct length and check digit)
  bool validateEan13(String barcode) {
    // Remove any whitespace
    barcode = barcode.trim();

    // Check length
    if (barcode.length != 13) {
      return false;
    }

    // Check if all characters are digits
    if (!RegExp(r'^\d+$').hasMatch(barcode)) {
      return false;
    }

    // Extract check digit
    final providedCheckDigit = int.parse(barcode[12]);
    
    // Calculate expected check digit
    final barcodeWithoutCheck = barcode.substring(0, 12);
    final calculatedCheckDigit = _calculateEan13CheckDigit(barcodeWithoutCheck);

    // Validate
    return providedCheckDigit == calculatedCheckDigit;
  }

  /// Check if a barcode was generated by this service
  /// 
  /// Returns true if the barcode starts with our internal prefix
  bool isInternallyGenerated(String barcode) {
    return barcode.startsWith(_prefix);
  }

  /// Extract product ID from an internally generated barcode
  /// 
  /// Returns the product ID, or null if the barcode is not internally generated
  int? extractProductId(String barcode) {
    if (!isInternallyGenerated(barcode) || barcode.length != 13) {
      return null;
    }

    // Extract the 9-digit product ID (positions 3-11)
    final productIdString = barcode.substring(3, 12);
    return int.tryParse(productIdString);
  }

  /// Format barcode for display with spaces
  /// 
  /// Example: 2000000000123 -> 200 000000 0123 (EAN-13 format)
  String formatBarcode(String barcode) {
    if (barcode.length != 13) {
      return barcode;
    }

    return '${barcode.substring(0, 3)} ${barcode.substring(3, 9)} ${barcode.substring(9, 13)}';
  }

  /// Generate a barcode suggestion based on the last used ID
  /// 
  /// This can be used to suggest a barcode when creating a new product
  String suggestBarcode(int lastProductId) {
    final nextId = lastProductId + 1;
    return generateBarcode(nextId);
  }
}
